---
layout: post
title:  "JavaScript æ­£åˆ™è¡¨è¾¾å¼(RegEx)å®žç”¨æŒ‡å—ã€è¯‘ã€‘"
date:   2019-10-06 10:24:00 +0800
categories: javascript
tags:
    - javascript
---
> å¿«é€Ÿå®žè·µæŒ‡å—ã€‚ç”¨ç¤ºä¾‹ç†è§£æ­£åˆ™è¡¨è¾¾å¼ã€‚

![](/img/in-post/2019-10-06-bg.png)  

å½“åˆæ¬¡è§åˆ°æ­£åˆ™è¡¨è¾¾å¼æ—¶ï¼Œå®ƒä»¬å¯èƒ½çœ‹èµ·æ¥åƒæ˜¯ä¹±ä¸ƒå…«ç³Ÿçš„éšæœºå­—ç¬¦ä¸²ã€‚å°½ç®¡å®ƒä»¬çœ‹èµ·æ¥è¯­æ³•æœ‰äº›æ··ä¹±ï¼Œä½†å®ƒä»¬å…¶å®žæ˜¯éžå¸¸æœ‰ç”¨ã€‚  

æ­£ç¡®ç†è§£æ­£åˆ™è¡¨è¾¾å¼èƒ½å¸®åŠ©ä½ æˆä¸ºæ›´æœ‰æ•ˆçš„ç¨‹åºå‘˜ã€‚ä¸ºäº†å…¨é¢äº†è§£æ­£åˆ™è¡¨è¾¾å¼ä¸–ç•Œï¼Œé¦–å…ˆéœ€è¦å­¦ä¹ åŸºç¡€æ¦‚å¿µï¼Œç„¶åŽåœ¨å…¶åŸºç¡€ä¸Šæ‰©å±•ã€‚  

äº‹ä¸å®œè¿Ÿï¼Œè®©æˆ‘ä»¬å¼€å§‹å§:)  

### ä»€ä¹ˆæ˜¯æ­£åˆ™è¡¨è¾¾å¼ï¼Ÿ
**æ­£åˆ™è¡¨è¾¾å¼æ˜¯ç”¨äºŽåŒ¹é…å­—ç¬¦ä¸²ä¸­å­—ç¬¦ç»„åˆçš„æ¨¡å¼ã€‚**å®ƒä»¬æž„æˆäº†è‡ªå·±çš„ä¸€é—¨å°è¯­è¨€ï¼Œæ˜¯è®¸å¤šç¼–ç¨‹è¯­è¨€(å¦‚Javascriptï¼ŒPerlï¼ŒPythonï¼ŒPhpå’ŒJava)çš„ä¸€éƒ¨åˆ†ã€‚  

æ­£åˆ™è¡¨è¾¾å¼å¸®åŠ©ä½ å¯ä»¥æ£€æŸ¥ä¾‹å¦‚ç”µå­é‚®ä»¶åœ°å€æˆ–å¯†ç ä¹‹ç±»çš„å­—ç¬¦ä¸²æ˜¯å¦ç¬¦åˆä¸€å®šçš„æ¨¡å¼ï¼Œè¿›ä¸€æ­¥å¤„ç†ç›¸å…³ä¿¡æ¯å’Œæç¤ºã€‚


### åˆ›å»ºä¸€ä¸ªæ­£åˆ™è¡¨è¾¾å¼
æœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥åœ¨Javascriptä¸­åˆ›å»ºæ­£åˆ™è¡¨è¾¾å¼ã€‚ å¯ä»¥ä½¿ç”¨`RegExp`æž„é€ å‡½æ•°åˆ›å»ºå®ƒï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ä¸¤ä¸ªæ­£æ–œæ (`/`)ã€‚

#### æ­£åˆ™è¡¨è¾¾å¼æž„é€ å‡½æ•°ï¼š
**è¯­æ³•**ï¼š`new RegExp(pattern [ï¼Œflags])`  

ä¾‹å¦‚ï¼š  
```js
var regexConst = new RegExp('abc');
```

#### æ­£åˆ™è¡¨è¾¾å¼å­—é¢é‡ï¼š
***è¯­æ³•***ï¼š`/pattern/flags`   

ä¾‹å¦‚ï¼š
```js
var regexLiteral = /abc/;
```

- è¿™äº›æ ‡å¿—(flags)æ˜¯å¯é€‰çš„ï¼Œæˆ‘å°†åœ¨æœ¬æ–‡åŽé¢è§£é‡Šã€‚  

åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå¯èƒ½æƒ³åŠ¨æ€åˆ›å»ºæ­£åˆ™è¡¨è¾¾å¼ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ­£åˆ™è¡¨è¾¾å¼   å­—é¢é‡ä¸èµ·ä½œç”¨ï¼Œå› æ­¤å¿…é¡»ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æž„é€ å‡½æ•°ã€‚  

æ— è®ºé€‰æ‹©å“ªç§æ–¹æ³•ï¼Œç»“æžœéƒ½å°†æ˜¯ä¸€ä¸ªæ­£åˆ™è¡¨è¾¾å¼å¯¹è±¡ã€‚ ä¸¤ä¸ªæ­£åˆ™è¡¨è¾¾å¼å¯¹è±¡éƒ½å°†å…·æœ‰ç›¸åŒçš„æ–¹æ³•å’Œå±žæ€§ã€‚  

**ç”±äºŽåœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­ä½¿ç”¨ä¸¤ä¸ªæ­£æ–œæ ï¼Œå› æ­¤ï¼Œå¦‚æžœè¦å°†æ­£æ–œæ (`/`)ç”¨ä½œæ­£åˆ™è¡¨è¾¾å¼çš„ä¸€éƒ¨åˆ†ï¼Œåˆ™å¿…é¡»ä½¿ç”¨åæ–œæ (`\`)è¿›è¡Œè½¬ä¹‰ã€‚**

### æ­£åˆ™è¡¨è¾¾å¼æ–¹æ³•
æµ‹è¯•æ­£åˆ™è¡¨è¾¾å¼çš„æ–¹æ³•ä¸»è¦æœ‰ä¸¤ç§ã€‚

#### RegExp.prototype.test()
ä¸€ä¸ªåœ¨å­—ç¬¦ä¸²ä¸­æµ‹è¯•æ˜¯å¦åŒ¹é…çš„RegExpæ–¹æ³•ï¼Œå®ƒè¿”å›ž `true` æˆ– `false`ã€‚

ä¾‹å¦‚ï¼š
```js
var regex = /hello/;
var str = 'hello world';
var result = regex.test(str);
console.log(result);
// returns true
```

#### RegExp.prototype.exec()
 
ä¸€ä¸ªåœ¨å­—ç¬¦ä¸²ä¸­æ‰§è¡ŒæŸ¥æ‰¾åŒ¹é…çš„RegExpæ–¹æ³•ï¼Œå®ƒè¿”å›žä¸€ä¸ªæ•°ç»„ï¼ˆæœªåŒ¹é…åˆ°åˆ™è¿”å›ž `null`ï¼‰ã€‚

ä¾‹å¦‚ï¼š
```js
var regex = /hello/;
var str = 'hello world';
var result = regex.exec(str);
console.log(result);
// returns [ 'hello', index: 0, input: 'hello world', groups: undefined ]
// 'hello' -> åŒ¹é…çš„å…¨éƒ¨å­—ç¬¦ä¸²
// index: -> åŒ¹é…åˆ°çš„å­—ç¬¦ä½äºŽåŽŸå§‹å­—ç¬¦ä¸²çš„åŸºäºŽ0çš„ç´¢å¼•å€¼
// input: -> åŽŸå§‹å­—ç¬¦ä¸²
```

æˆ‘ä»¬å°†åœ¨æœ¬æ–‡ä½¿ç”¨ `test()` æ–¹æ³•ã€‚



### Simple Regex Patterns
It is the most basic pattern, which simply matches the literal text with the test string. For example:
```js
var regex = /hello/;
console.log(regex.test('hello world'));
// true
```

### Special Characters
Up until now weâ€™ve created simple regular expression patterns. Now, letâ€™s tap into the full power of regular expressions when handling more complex cases.  

For example, instead of matching a specific email address letâ€™s say weâ€™d like to match a number of email addresses. Thatâ€™s where special characters come into play. There are special symbols and characters that you have to memorize in order to fully understand the regular expressions.  

#### Flags:
Regular expressions have five optional flags or modifiers. Letâ€™s discuss the two most important flags:  

- **g** â€” Global search, donâ€™t return after the first match
- **i** â€” Case-insensitive search  

You can also combine the flags in a single regular expression. Note that their order doesnâ€™t have any effect on the result.
Letâ€™s look at some code examples:  

##### Regular Expression Literal â€” Syntax `/pattern/flags`
```js
var regexGlobal = /abc/g;
console.log(regexGlobal.test('abc abc'));
// it will match all the occurence of 'abc', so it won't return 
// after first match.
var regexInsensitive = /abc/i;
console.log(regexInsensitive.test('Abc'));
// returns true, because the case of string characters don't matter 
// in case-insensitive search.
```

##### Regular Expression Constructor â€” Syntax `new RegExp('pattern', 'flags')`
```js
var regexGlobal = new RegExp('abc','g')
console.log(regexGlobal.test('abc abc'));
// it will match all the occurence of 'abc', so it won't return // after first match.
var regexInsensitive = new RegExp('abc','i')
console.log(regexInsensitive.test('Abc'));
// returns true, because the case of string characters don't matter // in case-insensitive search.
```

#### Character groups:
**Character set [xyz]** â€” A character set is a way to match different characters in a single position, it matches any single character in the string from characters present inside the brackets. For example:  

```js
var regex = /[bt]ear/;
console.log(regex.test('tear'));
// returns true
console.log(regex.test('bear'));
// return true
console.log(regex.test('fear'));
// return false
```

**Note** â€” All the special characters except for caret (^) (Which has entirely different meaning inside the character set) lose their special meaning inside the character set.  

***Negated character set [^xyz]** â€” It matches anything that is not enclosed in the brackets. For example:  

```js
var regex = /[^bt]ear/;
console.log(regex.test('tear'));
// returns false
console.log(regex.test('bear'));
// return false
console.log(regex.test('fear'));
// return true
```

Ranges [a-z] â€” Suppose we want to match all of the letters of an alphabet in a single position, we could write all the letters inside the brackets, but there is an easier way and that is ranges. For example: [a-h] will match all the letters from a to h. Ranges can also be digits like [0-9] or capital letters like [A-Z].

```js
var regex = /[a-z]ear/;
console.log(regex.test('fear'));
// returns true
console.log(regex.test('tear'));
// returns true
```

`Meta-characters` â€” Meta-characters are characters with a special meaning. There are many meta character but I am going to cover the most important ones here.  

- \d â€” Match any digit character ( same as [0-9] ).
- \w â€” Match any word character. A word character is any letter, digit, and underscore. (Same as [a-zA-Z0â€“9_] ) i.e alphanumeric character.
- \s â€” Match a whitespace character (spaces, tabs etc).
- \t â€” Match a tab character only.
- \b â€” Find a match at beginning or ending of a word. Also known as word boundary.
- . â€” (period) Matches any character except for newline.
- \D â€” Match any non digit character (same as [^0â€“9]).
- \W â€” Match any non word character (Same as [^a-zA-Z0â€“9_] ).
- \S â€” Match a non whitespace character.  

Quantifiers: â€” Quantifiers are symbols that have a special meaning in a regular expression.
- + â€” Matches the preceding expression 1 or more times.
```js
var regex = /\d+/;
console.log(regex.test('8'));
// true
console.log(regex.test('88899'));
// true
console.log(regex.test('8888845'));
// true
```

- * â€”Matches the preceding expression 0 or more times.
```js
var regex = /go*d/;
console.log(regex.test('gd'));
// true
console.log(regex.test('god'));
// true
console.log(regex.test('good'));
// true
console.log(regex.test('goood'));
// true
```

- ? â€” Matches the preceding expression 0 or 1 time, that is preceding pattern is optional.
```js
var regex = /goo?d/;
console.log(regex.test('god'));
// true
console.log(regex.test('good'));
// true
console.log(regex.test('goood'));
// false
```

- ^ â€” Matches the beginning of the string, the regular expression that follows it should be at the start of the test string. i.e the caret (^) matches the start of string.
```js
var regex = /^g/;
console.log(regex.test('good'));
// true
console.log(regex.test('bad'));
// false
console.log(regex.test('tag'));
// false
```

- $ â€” Matches the end of the string, that is the regular expression that precedes it should be at the end of the test string. The dollar ($) sign matches the end of the string.
```js
var regex = /.com$/;
console.log(regex.test('test@testmail.com'));
// true
console.log(regex.test('test@testmail'));
// false
```

- {N} â€” Matches exactly N occurrences of the preceding regular expression.
```js
var regex = /go{2}d/;
console.log(regex.test('good'));
// true
console.log(regex.test('god'));
// false
{N,} â€” Matches at least N occurrences of the preceding regular expression.
var regex = /go{2,}d/;
console.log(regex.test('good'));
// true
console.log(regex.test('goood'));
// true
console.log(regex.test('gooood'));
// true
```

- {N,M} â€” Matches at least N occurrences and at most M occurrences of the preceding regular expression (where M > N).
```js
var regex = /go{1,2}d/;
console.log(regex.test('god'));
// true
console.log(regex.test('good'));
// true
console.log(regex.test('goood'));
// false
```
- Alternation X|Y â€” Matches either X or Y. For example:
```js
var regex = /(green|red) apple/;
console.log(regex.test('green apple'));
// true
console.log(regex.test('red apple'));
// true
console.log(regex.test('blue apple'));
// false
```
Note â€” If you want to use any special character as a part of the expression, say for example you want to match literal + or ., then you have to escape them with backslash ( \ ).
For example:
```js
var regex = /a+b/;  // This won't work
var regex = /a\+b/; // This will work
console.log(regex.test('a+b')); // true
```
#### Advanced
(x) â€” Matches x and remembers the match. These are called capturing groups. This is also used to create sub expressions within a regular expression. For example :-
```js
var regex = /(foo)bar\1/;
console.log(regex.test('foobarfoo'));
// true
console.log(regex.test('foobar'));
// false
```
`\1` remembers and uses that match from first subexpression within parentheses.

`(?:x)` â€” Matches x and does not remember the match. These are called non capturing groups. Here \1 wonâ€™t work, it will match the literal \1.

```js
var regex = /(?:foo)bar\1/;
console.log(regex.test('foobarfoo'));
// false
console.log(regex.test('foobar'));
// false
console.log(regex.test('foobar\1'));
// true
```

`x(?=y)` â€” Matches x only if x is followed by y. Also called positive look ahead. For example:

```js
var regex = /Red(?=Apple)/;
console.log(regex.test('RedApple'));
// true
```

In the above example, match will occur only if Redis followed by Apple.

### Practicing Regex:
Letâ€™s practice some of the concepts that we have learned above.
- Match any 10 digit number :
```js
var regex = /^\d{10}$/;
console.log(regex.test('9995484545'));
// true
```

Letâ€™s break that down and see whatâ€™s going on up there.

1. If we want to enforce that the match must span the whole string, we can add the quantifiers ^ and $. The caret ^ matches the start of the input string, whereas the dollar sign $ matches the end. So it would not match if string contain more than 10 digits.  
2. `\d` matches any digit character.  
3. `{10}` matches the previous expression, in this case \d exactly 10 times. So if the test string contains less than or more than 10 digits, the result will be false.  

- Match a date with following format DD-MM-YYYY or DD-MM-YY
```js
var regex = /^(\d{1,2}-){2}\d{2}(\d{2})?$/;
console.log(regex.test('01-01-1990'));
// true
console.log(regex.test('01-01-90'));
// true
console.log(regex.test('01-01-190'));
// false
```
Letâ€™s break that down and see whatâ€™s going on up there.
1. Again, we have wrapped the entire regular expression inside ^ and $, so that the match spans entire string.
2. `(` start of first subexpression.
3. `\d{1,2}` matches at least 1 digit and at most 2 digits.
4. `-` matches the literal hyphen character.
5. `)` end of first subexpression.
6. `{2}` match the first subexpression exactly two times.
7. `\d{2}` matches exactly two digits.
8. `(\d{2})?` matches exactly two digits. But itâ€™s optional, so either year contains 2 digits or 4 digits.

- Matching Anything But a Newline
The expression should match any string with a format like abc.def.ghi.jkl where each variable a, b, c, d, e, f, g, h, i, j, k, l can be any character except new line.
```js
var regex = /^(.{3}\.){3}.{3}$/;
console.log(regex.test('123.456.abc.def'));
// true
console.log(regex.test('1243.446.abc.def'));
// false
console.log(regex.test('abc.def.ghi.jkl'));
// true
```

Letâ€™s break that down and see whatâ€™s going on up there.
1. We have wrapped entire regular expression inside ^ and $, so that the match spans entire string.
2. `(` start of first sub expression
3. `.{3}` matches any character except new line for exactly 3 times.
4. `\.` matches the literal . period
5. `)` end of first sub expression
6. `{3}` matches the first sub expression exactly 3 times.
7. `.{3}` matches any character except new line for exactly 3 times.

### Conclusion
Regular expression can be fairly complex at times, but having a proper understanding of the above concepts will help you understand more complex regex patterns easily. You can learn more about regex here and practice it here.


----
[åŽŸæ–‡é“¾æŽ¥ðŸ”—](https://blog.bitsrc.io/a-beginners-guide-to-regular-expressions-regex-in-javascript-9c58feb27eb4){:target="_blank"}